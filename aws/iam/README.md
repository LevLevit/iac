# Overview

This module updates the identify and access management configuration to set up roles and
policies to support System Manager related operations, such as automatic patching, and 
policies, groups, and users for developers and developer admins.

# AWS API Restriction by IP Ranges

The variable "networks" allows you to specify an IP range or ranges that AWS will require
as your source IP range for use of its API.  This allows us to restrict use of the API as
well as ingress to the bastion server by developers when they are not on the correct 
network.  The default allows access from any network.

# User Management

This module has a variable called "user_groups" in variables.tf that you'll update to 
create your users.  You can put users in one of two groups: dev or dev-admin.  

In addition to creating users and groups we also generate a keypair for each user.  These
keypairs can be used to authenticate users using the AWS CLI.  We do not set up console 
access for users at this time.  

To protect a user's secret key we require that each user provide a GPG public key, which 
we'll use to encrypt the users secret key.  Public keys reside in files under $IAC_HOME/keys.
They are named as ${user}-gpg.pub.

## Using GPG to encrypt generated keypairs

If you don't use GPG to encrypt the secrets generated by Terraform they will be stored
in clear text in the state file(s).  To avoid this we'll use a user's GPG public key
to encrypt his or her key pair secret.  This is provided back to the user encrypted and
they'll use GPG to decrypt it.

### Install

For users, the set up is simple.  You can google how to do this for your OS.  On Mac:

```
brew install gnupg
```

Add the following to whatever you use to initialize environment variables:

```
# GPG
GPG_TTY=$(tty)
export GPG_TTY
```

### Generate keys

```
gpg --generate-key
```

### List keys

```
gpg --list-keys
```

### Copy public key to $IAC_HOME/keys

You can use any attribute of the public key to export it.  I have "Dan" in my full
name so the command below works.  Use --list-keys to find what you need.  The key
will have an identifier that you could use as well or use your e-mail address.

```
gpg --export Dan | base64 > $IAC_HOME/keys/dan-gpg.pub
```

## Decrypt a Key Pair secret

All of the users specified in var.user_groups will get a key pair and the associated
secret will be encrypted with his or her GPG key (stored in $IAC_HOME/keys/user-gpg.pub).  

```
cd $IAC_HOME/aws/iam
terraform output --json | jq -r '.user_key_id.value[]'
```

### Get key and decrypt it

Send an entire stanza to your user.  Note the secret below is edited for brevity.

```
{
  "id": "AKX123...",
  "secret": "wcBURzAiUZHrZulpnTCN7LP+lsmWH/WHjPUBK9h6w7EWsgwUbJauP7Al8I3QmdpcqOxeDB4Gr60UkCVt==",
  "user": "dan.test"
}
```

The user will do something like:

```
echo "wcBMA6VJNd0Ej4fREA3454354345345345345345345345A...==" | base64 --decode | gpg --decrypt 
```

For yourself:

```
terraform output --json | jq -r '.user_key_id.value[] | select(.user=="dan.test") | .secret' \
    | base64 --decode \
    | gpg --decrypt --quiet
```

# Users, Groups, Policies, and Roles

Users have minimal priviledges.  They are able to manage credentials and MFA.  The basic
policies for this are attached to a group that is named after the user.  These policies
are user-specific, allowing access only to the user's own resources.

For other actions that a developer or developer admin would require, we create roles and
use role-base authentication, requiring MFA.

## Example user "dan"

The configuration below shows how roles are assumed.  The user is set up with his own 
stanza in the credentials file.  Then, a profile is created in ~/.aws/config for the
environment.  This configuration shows the rule the user will assume and also points 
to the user's MFA device (see below on how to configure MFA).  

Valid roles are:

* platform-test-dev-role
* platform-test-dev-admin-role

### AWS Credentials

[dan.test]
aws_access_key_id=A..M
aws_secret_access_key=R..Q

### AWS Config

[profile test]
region = us-east-2
source_profile = dan.test
role_arn       = arn:aws:iam::12345678910:role/platform-test-dev-role
mfa_serial     = arn:aws:iam::12345678910:mfa/dan.test

# Adding Virtual MFA via the AWS CLI

This section talks about how to set up MFA from the AWS CLI.  The create command below 
generates a QR Code.  Use that with your virtual MFA app.  Then make the enable call to
enable the device for the user.  That command requires two generated access codes from
the virtual MFA device.

## Create a Virual MFA Device

```
aws iam create-virtual-mfa-device --virtual-mfa-device-name dan.test --outfile ./qrcode.png --bootstrap-method QRCodePNG --profile dan.test
```

This returns something like:

```
{
    "VirtualMFADevice": {
        "SerialNumber": "arn:aws:iam::12345678910:mfa/dan.test"
    }
}
```
## Enable the Device

```
aws iam enable-mfa-device \
    --profile dan.test \
    --user-name dan.test \
    --serial-number arn:aws:iam::12345678910:mfa/dan.test" \
    --authentication-code1 123456 \
    --authentication-code2 789012
```
# AWS Vault (experimenting)

```
brew install aws-vault
```

## IAM and MFA

When you make calls related to IAM, AWS is not going to authorized the call if you have
an account that is MFA enabled but hasn't passed MFA tokens.  In this particular case 
the command below should work before MFA is enabled but not after.

```
aws iam list-users --profile dan.test
```


After MFA is enabled, you will need to do the following:

```
aws-vault exec dan.test --no-session -- aws iam list-users
```

See https://github.com/99designs/aws-vault/issues/260 for details.